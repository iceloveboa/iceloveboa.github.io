<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="icon" type="image/jpeg" href="avatar.jpg">
	<style type="text/css">
	body{text-align:center;}
	div{width:778px;margin:0 auto;background:#fff;text-align:left;}
	.continer{width:778px;}
	</style>
</head>
<body>
	<div class="continer">
     <ul>
<li><a href="https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find Minimum in Rotated Sorted Array</a></li>
</ul>


<pre><code>class Solution {

public:

    int findMin(vector&lt;int&gt; &amp;num) {

        int result = 0;

        long left = 0;

        long right = num.size()-1;

        long middle;

        while (left &lt;= right) {

            if (left == right) {

                result = num[left];

                break;

            }

            if (num[left]&lt;num[right]) {

                result = num[left];

                break;

            }else{

                middle = (left + right)/2;

                if (left == middle) {

                    left = middle + 1;

                }

                else if (num[left]&lt;num[middle]) {

                    left = middle;

                }else{

                    right = middle;

                }

            }

        }

        return result;

    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/maximum-product-subarray/">Maximum Product Subarray</a></li>
</ul>


<pre><code>class Solution {

public:

    int maxProduct(int A[], int n) {

       int result = A[0];

       int mini = A[0];

       int maxi = A[0];

        for(int i=1;i&lt;n;i++)

        {

           int a = min(maxi*A[i],mini*A[i]);

           int b = max(mini*A[i],maxi*A[i]);

           mini = min(A[i],a);

           maxi = max(A[i],b);

           result = max(result,maxi);

        }

        return result;

    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/reverse-words-in-a-string/">Reverse Words in a String</a></li>
</ul>


<pre><code>class Solution {

public:

    void reverseWords(string &amp;s) {

        string result;

        istringstream iss(s);

        do{

            string word;

            iss&gt;&gt;word;

            result=word+" "+result;

        }while (iss);

        result = result.substr(1,result.length()-2);

        s=result;

    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">Evaluate Reverse Polish Notation</a></li>
</ul>


<pre><code>class Solution {

public:

    int evalRPN(vector&lt;string&gt; &amp;tokens) {

        stack&lt;int&gt; stack;

        for (int i=0; i&lt;tokens.size(); i++) {

            string s = tokens[i];

            if (s=="+" || s == "-" || s== "*" || s=="/" ) {

                int a = stack.top();

                stack.pop();

                int b = stack.top();

                stack.pop();

                if (s == "+") {

                    stack.push(a+b);

                }else if(s == "-"){

                    stack.push(b-a);

                }else if(s == "*"){

                    stack.push(a*b);

                }else if(s == "/"){

                    stack.push(b/a);

                }

            }else{

                stack.push( atoi(s.c_str()));

            }

        }

        return stack.top();

    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/max-points-on-a-line/">Max Points on a Line</a></li>
</ul>


<pre><code>/**

 * Definition for a point.

 * struct Point {

 *     int x;

 *     int y;

 *     Point() : x(0), y(0) {}

 *     Point(int a, int b) : x(a), y(b) {}

 * };

 */

 #include &lt;cmath&gt;



class Solution {

public:

    int maxPoints(vector&lt;Point&gt; &amp;points) {

        int maxNum = 0;

        unordered_map&lt;float, int&gt; mp;

        for (int i=0; i&lt; points.size(); i++) {

            mp.clear();

            int dup = 1;

            for (int j = i+1; j&lt;points.size(); j++) {

                if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) {

                    dup++;

                    continue;

                }



                if (points[i].x == points[j].x) {

                    mp[INT_MAX]++;

                }else{

                    mp[(float)(points[i].y-points[j].y)/(points[i].x-points[j].x)]++;

                }

            }



            maxNum = dup &gt; maxNum ? dup : maxNum;

            for (unordered_map&lt;float, int&gt;::iterator it = mp.begin();it!=mp.end();it++)

            {

                if (it-&gt;second + dup  &gt; maxNum) {

                    maxNum = it-&gt;second+dup;

                }

            }

        }





        return maxNum;

    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/sort-list/">Sort List</a></li>
</ul>


<pre><code>/**

 * Definition for singly-linked list.

 * struct ListNode {

 *     int val;

 *     ListNode *next;

 *     ListNode(int x) : val(x), next(NULL) {}

 * };

 */

class Solution {

public:

    ListNode *findMiddle(ListNode *node){

        ListNode *fast=node;

        ListNode *slow=node;

        while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) {

            slow = slow -&gt; next;

            fast = fast -&gt; next -&gt; next;

        }

        return slow;

    }

    ListNode *sortList(ListNode *head) {

        if (head == NULL || head -&gt; next == NULL) {

            return head;

        }



        ListNode *middle = findMiddle(head);

        ListNode *next = middle -&gt; next;

        middle -&gt; next = NULL;

        return mergeList(sortList(head),sortList(next));

    }



    ListNode *mergeList(ListNode *list1,ListNode *list2){

        ListNode *re =new ListNode(-1);

        ListNode *cur = re;

        while (list1 != NULL &amp;&amp; list2 != NULL) {

            if (list1 -&gt; val &lt; list2 -&gt; val) {

                cur -&gt; next = list1 ;

                list1 = list1 -&gt; next;

            }else{

                cur -&gt; next = list2;

                list2 = list2 -&gt; next;

            }

            cur = cur -&gt; next;

        }



        cur -&gt;next = list1 != NULL ? list1 : list2 ;

        return re-&gt;next;



    }



};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/insertion-sort-list/">Insertion Sort List</a></li>
</ul>


<pre><code>/**

 * Definition for singly-linked list.

 * struct ListNode {

 *     int val;

 *     ListNode *next;

 *     ListNode(int x) : val(x), next(NULL) {}

 * };

 */

class Solution {

public:

    ListNode *insertionSortList(ListNode *head) {

        if (head == NULL || head -&gt; next == NULL) {

            return head;

        }



        ListNode *cur = head -&gt; next;

        head -&gt; next = NULL;



        while (cur != NULL) {



             ListNode *next = cur -&gt; next;



            ListNode *temp = head;

            ListNode *pre = temp;

            while (temp != NULL) {

                if (temp -&gt; val &gt; cur -&gt; val) {

                    if (temp == head) {

                        cur -&gt; next = head;

                        head = cur;

                    }else{

                        cur -&gt; next = temp;

                        pre -&gt; next = cur;

                    }

                    break;

                }else{

                    if (temp-&gt;next == NULL) {

                        temp -&gt; next = cur;

                        cur -&gt; next = NULL;

                        break;

                    }else{

                        pre = temp;

                        temp = temp -&gt; next;

                    }

                }

            }



            cur = next;

        }



        return head;





    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/lru-cache/">LRU Cache</a></li>
</ul>


<pre><code>struct UsedFreq {
    int key;
    int value;
    int times;
    UsedFreq()
    {
        key = 0;
        value = 0;
        times = 0;
    }
    UsedFreq(int _key,int _value,int _times){
        key = _key;
        value = _value;
        times = _times;
    }
};

class LRUCache{
public:
    unordered_map&lt;int,list&lt;UsedFreq&gt;::iterator&gt; _cachs;
    int _capacity;
    int _used;
    list&lt;UsedFreq&gt; its;
    LRUCache(int capacity) {
        _capacity = capacity;
        _cachs.clear();
        its.clear();
        _used = 1;
    }

    int get(int key) {
        unordered_map&lt;int,list&lt;UsedFreq&gt;::iterator&gt;::iterator it = _cachs.find(key);
        if (it!= _cachs.end()) {
            its.erase(it-&gt;second);
            its.push_front(UsedFreq(key,it-&gt;second-&gt;value,_used++));
            _cachs[key] = its.begin();
            return _cachs[key]-&gt;value;
        }else{
            return -1;
        }
    }

    void set(int key, int value) {
        unordered_map&lt;int,list&lt;UsedFreq&gt;::iterator&gt;::iterator it = _cachs.find(key);
        if (it!= _cachs.end()) {
            its.erase(it-&gt;second);
            its.push_front(UsedFreq(key,value,_used++));
            _cachs[key] = its.begin();
        }else{
            if (_cachs.size()==_capacity) {
                _cachs.erase((--its.end())-&gt;key);
                its.erase(--its.end());

            }

            its.push_front(UsedFreq(key,value,_used++));
            _cachs[key] = its.begin();
                }
    }
};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/">Binary Tree Preorder Traversal</a></li>
</ul>


<pre><code>//Recursive

class Solution {

public:

    vector&lt;int&gt; re;


    vector&lt;int&gt; preorderTraversal(TreeNode *root) {

        if (root!=NULL) {
            re.push_back(root-&gt;val);
            preorderTraversal(root-&gt;left);
            preorderTraversal(root-&gt;right);
        }
        return re;

    }

};

//iteratively
class Solution {

public:

    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; re;

        stack&lt;TreeNode*&gt; nodes;
        TreeNode *current = root;
        if (root!=NULL) {
             nodes.push(current);
        }

        while (!nodes.empty() || current != NULL) {
            while (current!=NULL) {
                if (current != root) {
                    nodes.push(current);
                }
                re.push_back(current-&gt;val);
                current = current-&gt;left;
            }

            TreeNode *node = nodes.top();
            current = node-&gt;right;
            nodes.pop();


        }

        return re;

    }

};
</code></pre>

<ul>
<li><a href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/">Binary Tree Postorder Traversal</a></li>
</ul>


<pre><code>//Recursive
class Solution {

public:



    vector&lt;int&gt; re;



    vector&lt;int&gt; postorderTraversal(TreeNode *root) {

        if (root!=NULL) {

            postorderTraversal(root-&gt;left);

            postorderTraversal(root-&gt;right);

            re.push_back(root-&gt;val);

        }

        return re;

    }

};

//iteratively
class Solution {

public:



    vector&lt;int&gt; re;



    vector&lt;int&gt; postorderTraversal(TreeNode *root) {



        vector&lt;int&gt; re;

        stack&lt;TreeNode *&gt; nodes;

        TreeNode *current = root;

        if(current!=NULL)

            nodes.push(current);

        TreeNode *pre = root;

        while (!nodes.empty()) {

            current = nodes.top();

            if ((current-&gt;left==NULL&amp;&amp;current-&gt;right==NULL)||(pre==current-&gt;left || pre==current-&gt;right)) {

                re.push_back(current-&gt;val);

                pre=current;

                nodes.pop();



            }

            else{

                if (current-&gt;right!=NULL) {

                    nodes.push(current-&gt;right);

                }

                if (current-&gt;left!=NULL) {

                    nodes.push(current-&gt;left);

                }

            }





        }

        return re;

    }

};
</code></pre>   
    </div>
</body>
</html>